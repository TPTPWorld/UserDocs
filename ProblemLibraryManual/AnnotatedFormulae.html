<A NAME="AnnotatedFormulae">
<H3> Annotated Formulae </H3>

TPTP problems and TSTP solutions are built from <EM>annotated formulae</EM> of the form
<EM>language</EM><TT>(</TT><EM>name</EM><TT>,</TT><EM>role</EM><TT>,</TT><EM>formula</EM><TT>,</TT><EM>source</EM><TT>,</TT><TT>[</TT><EM>useful_info</EM><TT>]).</TT>.
The <EM>language</EM>s currently supported are 
<TT>thf</TT> - formulae in typed higher-order form,
<TT>tff</TT> - formulae in typed first-order form (including extended form),
<TT>fof</TT> - formulae in first order form, 
and 
<TT>cnf</TT> - formulae in clause normal form.
The <EM>name</EM> identifies the formula within the problem.
The <EM>role</EM> gives the user semantics of the <EM>formula</EM>, one of
<TT>axiom</TT>, <TT>hypothesis</TT>, <TT>definition</TT>, <TT>assumption</TT>,
<TT>lemma</TT>, <TT>theorem</TT>, <TT>corollary</TT>, <TT>conjecture</TT>, 
<TT>negated_conjecture</TT>, <TT>plain</TT>, <TT>type</TT>, <TT>interpretation</TT>, 
<TT>logic</TT>, and 
<TT>unknown</TT>.
<UL>
<LI> The <EM>axiom-like</EM> formulae are those with the roles
     <TT>axiom</TT>, <TT>hypothesis</TT>, <TT>definition</TT>, <TT>assumption</TT>,
     <TT>lemma</TT>, <TT>theorem</TT>, and <TT>corollary</TT>.
      They are accepted, without proof, as a basis for proving <TT>conjecture</TT>s 
      in THF, TFF, and FOF problems.
      In CNF problems the axiom-like formulae are accepted as part of the set whose 
      satisfiability has to be established.
      There is no guarantee that the axiom-like formulae of a problem are consistent.
<LI> <TT>hypothesis</TT>s are assumed to be true for a particular problem.
<LI> <TT>definition</TT>s are used to define symbols.
<LI> <TT>assumption</TT>s must be discharged before a derivation is complete.
<LI> <TT>lemma</TT>s and <TT>theorem</TT>s have been proven from the other 
      axiom-like formulae, and are thus redundant wrt those axiom-like formulae.
     <TT>theorem</TT> is used also as the role of proven <TT>conjecture</TT>s, in output.
     A problem containing a <TT>lemma</TT> or <TT>theorem</TT> that is not 
     redundant wrt the other axiom-like formulae is ill-formed.
     <TT>theorem</TT>s are more important than <TT>lemma</TT>s from the
     user perspective.
<LI> <TT>corollary</TT>s have been proven from the <TT>axiom</TT>s and a
     <TT>theorem</TT>, and are thus redundant wrt the other axiom-like and 
     <TT>theorem</TT> formulae.
     A problem containing a <TT>corollary</TT> that is not redundant wrt the 
     other axiom-like formulae and <TT>theorem</TT> formulae is ill-formed.
<LI> <TT>conjecture</TT>s occur in only THF, TFF, and FOF problems, and are to all 
     be proven from the axiom-like formulae.
     A problem is solved only when all conjectures are proven.
     (<EM>TPTP problems never contain more than one </EM><TT>conjecture</TT><EM>, 
     and the creation of problems with more than one </EM><TT>conjecture</TT><EM>
     is currently deprecated, because contemporary ATP systems commonly treat them 
     as a disjunction, and will prove only one of them</EM>.) 
<LI> <TT>negated_conjecture</TT>s are formed from negation of a <TT>conjecture</TT>,
     typically in FOF to CNF conversion.
<LI> <TT>plain</TT> formulae have no special user semantics, and are typically used in derivation 
     output.
<LI> <TT>type</TT> formulae define the types of symbols globally.
<LI> <TT>interpretation</TT> formulae are used for writing interpretations, typically models of
     satisfiable sets of formulae, in particular the <TT>axiom</TT>s and <TT>negated_conjecture</TT>
     of a non-theorem.
<LI> <TT>logic</TT> formulae are used for defining the logic in <A HREF="#NonClassicalLogics">
     non-classical logics</A>.
<LI> <TT>unknown</TT>s have unknown role, and this is an error situation.
</UL>
<P>
The syntax for atoms is that of Prolog:
variables start with upper case letters,
atoms and terms are written in prefix notation,
uninterpreted predicates and functors either start with lower case
and contain alphanumerics and underscore, or are in <TT>'single quotes'</TT>.
The language also supports interpreted predicates and functors.
These come in two varieties: <EM>defined</EM> predicates and functors, whose
interpretation is specified by the TPTP language, and <EM>system</EM>
predicates and functors, whose interpretation is ATP system specific.
Interpreted predicates and functors are syntactically distinct from
uninterpreted ones - they are <TT>=</TT> and <TT>!=</TT>, or start with 
a <TT>$</TT>, a <TT>"</TT>, or a digit.
Non-variable symbols can be given a type globally, in the formula with
role <TT>type</TT>.
The defined types are
<TT>$o</TT> - the Boolean type,
<TT>$i</TT> - the type of individuals,
<TT>$real</TT> - the type of reals,
<TT>$rat</TT> - the type of rational,
and
<TT>$int</TT> - the type of integers.
New types are introduced in formulae with the <TT>type</TT> role, based on
<TT>$tType</TT> - the type of all types.
Full details of the THF and TFF type systems are provided in
[<A HREF="../../cgi-bin/SeeTPTP?Category=BibTeX&File=SS+12">SS+12</A>,<A HREF="../../cgi-bin/SeeTPTP?Category=BibTeX&File=BP13-TFF1">BP13</A>,<A HREF="../../cgi-bin/SeeTPTP?Category=BibTeX&File=SB10">SB10</A>,<A HREF="../../cgi-bin/SeeTPTP?Category=BibTeX&File=KSR16">KSR16</A>],
with the last providing an overview of the first three.
<P>
The defined predicates recognized so far are 
<UL>
<LI> <TT>$true</TT> and <TT>$false</TT>, with the obvious interpretations.
     In typed languages they are of type <TT>$o</TT>.
<LI> <TT>=</TT> and <TT>!=</TT> for equality and inequality. 
     In typed languages they are ad hoc polymorphic with both sides having 
     the same type.
<LI> <TT>$distinct</TT>, whose arguments are hence known to be unequal from
     each other (but not necessarily unequal to any other constants).
     <TT>$distinct</TT> maybe overloaded with different arities.
     <TT>$distinct</TT> is used in only the typed languages, and is ad hoc
     polymorphic with all arguments having the same type.
<LI> The <A HREF="#Arithmetic">arithmetic predicates</A> described below.
     The arithmetic predicates are used in only the THF and TFF languages.
</UL>
The defined functors recognized so far are 
<UL>
<LI> <TT>"distinct object"</TT>s, written in double quotes.
     All <TT>"distinct object"</TT>s are unequal to all <TT>"different 
     distinct object"</TT>s (but not necessarily unequal to any other 
     constants), e.g., <TT>"Apple" != "Microsoft"</TT>.
     One way of implementing this is to interpret <TT>"distinct object"</TT> 
     as the domain element in the double quotes.
     In typed contexts <TT>"distinct object"</TT>s are of type <TT>$i</TT>
     (and as a result, are unequal to all numbers because their interpretation
     domains are disjoint in the TPTP type systems).
<LI> Numbers (numeric constants).
     These are used in the THF and TFF languages.
     Numbers are interpreted as themselves (as domain elements).
     All different numbers are unequal, e.g., <TT>1 != 2</TT> 
     (but not necessarily unequal to any other constants).
     All numbers are also unequal to terms of type <TT>$i</TT> (because 
     their interpretation domains are disjoint in the TPTP type systems).
     Numbers are not allowed in FOF and CNF, but for many applications an
     adequate alternative is to write "numbers" as distinct objects, 
     e.g., <TT>"27"</TT>, so that different "numbers" are known to be 
     unequal to each other, but possibly equal to other terms of type 
     <TT>$i</TT>.
<LI> The <A HREF="#Arithmetic">arithmetic functions</A> described below.
     The arithmetic functions are used in only the THF and TFF languages.
</UL>
<P>
System predicates and functors are used for interpreted predicates and
functors that are available in particular ATP tools.
System predicates and functors start with <TT>$$</TT>.
The names are not controlled by the TPTP language, so they must be used
with caution.
<P>
The connectives used to build non-atomic formulae are written using intuitive 
notations.
The universal quantifier is <TT>!</TT>, the existential quantifier is
<TT>?</TT>, and the lambda binder is <TT>^</TT>.
Quantified formulae are written in the form
<EM>Quantifier</EM>&nbsp;<TT>[</TT><EM>Variables</EM><TT>]&nbsp;:</TT>&nbsp;<EM>
Formula</EM>.
In the THF, TFF, and FOF languages, every variable in a <EM>Formula</EM> 
must be bound by a preceding quantification with adequate scope.
Typed <EM>Variables</EM> are given their type by a <TT>:</TT><EM>type</EM> 
suffix.
The binary connectives are
infix <TT>|</TT> for disjunction, 
infix <TT>&</TT> for conjunction,
infix <TT>&lt;=&gt;</TT> for equivalence,
infix <TT>=&gt;</TT> for implication,
infix <TT>&lt;=</TT> for reverse implication,
infix <TT>&lt;~&gt;</TT> for non-equivalence (XOR),
infix <TT>~|</TT> for negated disjunction (NOR),
infix <TT>~&</TT> for negated conjunction (NAND),
infix <TT>@</TT> for application.
The only unary connective is prefix <TT>~</TT> for negation.
Negation has higher precedence than quantification, which in turn has
higher precedence than the binary connectives.
No precedence is specified between the binary connectives; brackets are 
used to ensure the correct association.
The binary connectives are left associative.
<P>
The THF and TFF languages have conditional and let expressions.
<UL>
<LI> Conditional expressions have <TT>$ite</TT> as the functor. 
     The expressions are parametric polymorphic, taking a boolean expression as 
     the first argument, then two expressions of any one type as the second and 
     third arguments, as the true and false return values respectively, i.e., 
     the return type is the same as that of the second and third arguments.
     Let expressions have <TT>$let</TT> as the functor.
<LI> The expressions provide the types of defined symbols, definitions for the
     symbols, and a formula/term in which the definitions are applied.
     Each type declaration is the same as a type declaration in an annotated
     formula with the <TT>type</TT> role, and multiple type declarations are given
     in <TT>[]</TT>ed tuples of declarations.
     Each definition defines the expansion of one of the declared symbols, and
     multiple definitions are given in <TT>[]</TT>ed tuples of definitions.
     If variables are used in the lefthand side of a definition, their values
     are supplied in the defined symbol's use.
     Such variables do not need to be declared (they are implicitly declared to
     be of the type defined by the symbol declaration), but must be top-level
     arguments of the defined symbol and be pairwise distinct.
     In the polymorphic case, type declarations may include type variables introduced in an enclosing scope, such as
<PRE>
tff(let_polymorphic_both_types, axiom,
  ![A: $tType]: $let(
    % the constant function using A from 'outside' and B from 'inside'
    const : !>[B : $tType]: (A * B) > A,
    % B required here but not A
    const(B, X, Y) := X)).
</PRE>
     No extra sort arguments are needed when using such $let-defined symbols.
</UL>
<P>
The <EM>useful_info</EM> field of an annotated formula is optional, and if
it is not used then the <EM>source</EM> field becomes optional.
The  source field is used to record where the annotated formula came from,
and is most commonly a <TT>file</TT> record or an <TT>inference</TT> record.
A <TT>file</TT> record stores the name of the file from which the annotated
formula was read, and optionally the name of the annotated formula as it
occurs in that file - this might be different from the name of the annotated
formula itself, e.g., if an ATP systems reads an annotated formula,
renames it, and then prints it out.
An <TT>inference</TT> record stores information about an inferred formula.
The <EM>useful_info</EM> field of an annotated formula is a list of arbitrary
useful information formatted as Prolog terms, as required for user
applications.
<P>
An example of a THF formula section, extracted from the problem file
<TT>LCL633^1.p</TT>, is shown below.
An example of a TFF formula section, extracted from the problem file
<TT>DAT013=1.p</TT>, is shown below that.
Example THF formulae</A>.
An example of a FOF formula section, extracted from the problem file
<TT>GRP194+1.p</TT>, is shown below that.
An example of a clause section, extracted from the problem file
<TT>GRP039-7.p</TT>, is shown below that.
<P>
<A NAME="THF formulae">
<PRE>
%------------------------------------------------------------------------------
%----Signature
thf(a,type,(
    a: $tType )).

thf(p,type,(
    p: ( a > $i > $o ) > $i > $o )).

thf(g,type,(
    g: a > $i > $o )).

thf(e,type,(
    e: ( a > $i > $o ) > a > $i > $o )).

thf(r,type,(
    r: $i > $i > $o )).

%----Axioms
thf(positiveness,axiom,(
    ! [X: a > $i > $o] :
      ( mvalid
      @ ( mimpl @ ( mnot @ ( p @ X ) )
        @ ( p
          @ ^ [Z: a] :
              ( mnot @ ( X @ Z ) ) ) ) ) )).

thf(g,definition,
    ( g
    = ( ^ [Z: a,W: $i] :
        ! [X: a > $i > $o] :
          ( mimpl @ ( p @ X ) @ ( X @ Z ) @ W ) ) )).

thf(e,definition,
    ( e
    = ( ^ [X: a > $i > $o,Z: a,P: $i] :
        ! [Y: a > $i > $o] :
          ( mimpl @ ( Y @ Z )
          @ ( mbox @ r
            @ ^ [Q: $i] :
              ! [W: a] :
                ( mimpl @ ( X @ W ) @ ( Y @ W ) @ Q ) )
          @ P ) ) )).

%----Conjecture
thf(thm,conjecture,
    ( mvalid
    @ ^ [W: $i] :
      ! [Z: a] :
        ( mimpl @ ( g @ Z ) @ ( e @ g @ Z ) @ W ) )).
%------------------------------------------------------------------------------
</PRE>
<CENTER>
<U>Example of a THF problem file formulae section (<TT>LCL633^1.p</TT>).</U>
</CENTER>
<A NAME="THF formulae">
<PRE>
%------------------------------------------------------------------------------
tff(list_type,type,(
    list: $tType )).

tff(nil_type,type,(
    nil: list )).

tff(mycons_type,type,(
    mycons: ( $int * list ) > list )).

tff(sorted_type,type,(
    fib_sorted: list > $o )).

tff(empty_fib_sorted,axiom,(
    fib_sorted(nil) )).

tff(single_is_fib_sorted,axiom,(
    ! [X: $int] : fib_sorted(mycons(X,nil)) )).

tff(double_is_fib_sorted_if_ordered,axiom,(
    ! [X: $int,Y: $int] :
      ( $less(X,Y)
     => fib_sorted(mycons(X,mycons(Y,nil))) ) )).

tff(recursive_fib_sort,axiom,(
    ! [X: $int,Y: $int,Z: $int,R: list] :
      ( ( $less(X,Y)
        & $greatereq(Z,$sum(X,Y))
        & fib_sorted(mycons(Y,mycons(Z,R))) )
     => fib_sorted(mycons(X,mycons(Y,mycons(Z,R)))) ) )).

tff(check_list,conjecture,(
    fib_sorted(mycons(1,mycons(2,mycons(4,mycons(7,mycons(100,nil)))))) )).
%------------------------------------------------------------------------------
</PRE>
<CENTER>
<U>Example of a TFF problem file formulae section (<TT>DAT002=1.p</TT>).</U>
</CENTER>
<A NAME="FOF formulae">
<PRE>
%--------------------------------------------------------------------------
%----Definition of a homomorphism
fof(homomorphism1,axiom,
    ( ! [X] :
        ( group_member(X,f)
       => group_member(phi(X),h) ) )).

fof(homomorphism2,axiom,
    ( ! [X,Y] :
        ( ( group_member(X,f)
          & group_member(Y,f) )
       => multiply(h,phi(X),phi(Y)) = phi(multiply(f,X,Y)) ) )).

fof(surjective,axiom,
    ( ! [X] :
        ( group_member(X,h)
       => ? [Y] :
            ( group_member(Y,f)
            & phi(Y) = X ) ) )).

%----Definition of left zero
fof(left_zero,axiom,
    ( ! [G,X] :
        ( left_zero(G,X)
      <=> ( group_member(X,G)
          & ! [Y] :
              ( group_member(Y,G)
             => multiply(G,X,Y) = X ) ) ) )).

%----The conjecture
fof(left_zero_for_f,hypothesis,
    ( left_zero(f,f_left_zero) )).

fof(prove_left_zero_h,conjecture,
    ( left_zero(h,phi(f_left_zero)) )).
%--------------------------------------------------------------------------
</PRE>
<CENTER>
<U>Example of a FOF problem file formulae section (<TT>GRP194+1.p</TT>).</U>
</CENTER>
<P>
<A NAME="CNF clauses">
<PRE>
%--------------------------------------------------------------------------
%----Redundant two axioms
cnf(right_identity,axiom,
    ( multiply(X,identity) = X )).

cnf(right_inverse,axiom,
    ( multiply(X,inverse(X)) = identity )).

... some clauses omitted here for brevity

cnf(property_of_O2,axiom,
    ( subgroup_member(X)
    | subgroup_member(Y)
    | multiply(X,element_in_O2(X,Y)) = Y )).

%----Denial of theorem
cnf(b_in_O2,negated_conjecture,
    ( subgroup_member(b) )).

cnf(b_times_a_inverse_is_c,negated_conjecture,
    ( multiply(b,inverse(a)) = c )).

cnf(a_times_c_is_d,negated_conjecture,
    ( multiply(a,c) = d )).

cnf(prove_d_in_O2,negated_conjecture,
    ( ~ subgroup_member(d) )).
%--------------------------------------------------------------------------
</PRE>
<CENTER>
<U>Example of a CNF problem file clause section (<TT>GRP039-7.p</TT>).</U>
</CENTER>

